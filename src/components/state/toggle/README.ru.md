# Компонент Toggle

Простая утилита для управления булевым состоянием в React приложениях с использованием паттерна render props.

## Описание

Компонент `Toggle` предоставляет простой и эффективный способ управления булевым состоянием в React приложениях. Он использует паттерн render props для предоставления состояния и функций управления дочерним компонентам. Компонент поддерживает колбэки изменения состояния и предоставляет несколько методов для управления состоянием.

## Когда использовать

- **UI переключатели и выключатели**: Переключатели темного режима, флаги функций, выключатели настроек
- **Логика показа/скрытия**: Сворачиваемые секции, расширяемый контент, видимость модальных окон
- **Элементы управления формы**: Чекбоксы, альтернативы радио-кнопок, переключатели полей формы
- **Флаги функций**: Включение/отключение функций, переключатели бета-функций
- **Управление предпочтениями**: Пользовательские предпочтения, настройки уведомлений, контроль приватности
- **Условный рендеринг**: Переключение между различными представлениями или компонентами
- **Аккордеон и сворачиваемый контент**: Расширение/сворачивание секций контента

## Как это работает

Компонент `Toggle` управляет булевым состоянием с помощью простого API:

1. **Управление состоянием**: Обрабатывает состояние true/false с опциональным начальным значением
2. **Render Props**: Предоставляет состояние и функции управления через children функцию
3. **Колбэки**: Поддерживает колбэк onChange для уведомления об изменениях
4. **Множественные методы управления**: toggle, setOn, setOff, setState для различных сценариев

## Используемые паттерны

- **Паттерн Render Props**: Предоставляет состояние и функции управления через children
- **Паттерн наблюдателя**: Колбэки для уведомлений об изменении состояния
- **Паттерн оптимизации**: Оптимизированные обновления состояния
- **Типобезопасность**: Полная поддержка TypeScript

## TypeScript типы

```typescript
/**
 * Пропсы для компонента Toggle
 */
interface ToggleProps {
  /** Начальное состояние переключателя */
  initial?: boolean;
  /** Функция рендеринга children */
  children: (state: ToggleState) => React.ReactNode;
  /** Колбэк при изменении состояния переключателя */
  onChange?: (state: ToggleState) => void;
}

/**
 * Информация о состоянии переключателя
 */
interface ToggleState {
  /** Текущее состояние переключателя */
  on: boolean;
  /** Переключить состояние */
  toggle: () => void;
  /** Включить */
  setOn: () => void;
  /** Выключить */
  setOff: () => void;
  /** Установить конкретное состояние */
  setState: (on: boolean) => void;
}
```

## Справочник API

| Проп | Тип | Обязательный | По умолчанию | Описание |
|------|-----|--------------|--------------|----------|
| `initial` | `boolean` | | `false` | Начальное состояние переключателя |
| `children` | `(state: ToggleState) => ReactNode` | ✅ | - | Функция рендеринга с состоянием и методами управления |
| `onChange` | `(state: ToggleState) => void` | | - | Колбэк при изменении состояния переключателя |

## Примеры

### Базовый переключатель
```tsx
import { Toggle } from 'ui-magic-core';

function BasicToggle() {
  return (
    <Toggle initial={false}>
      {({ on, toggle }) => (
        <button
          onClick={toggle}
          className={`toggle-btn ${on ? 'on' : 'off'}`}
          aria-pressed={on}
        >
          {on ? 'ВКЛ' : 'ВЫКЛ'}
        </button>
      )}
    </Toggle>
  );
}
```

### Переключатель с колбэком изменения состояния
```tsx
function CallbackToggle() {
  return (
    <Toggle 
      initial={false}
      onChange={(state) => console.log('Состояние переключателя:', state)}
    >
      {({ on, toggle }) => (
        <button onClick={toggle}>
          {on ? 'ВКЛ' : 'ВЫКЛ'}
        </button>
      )}
    </Toggle>
  );
}
```

### Переключатель со всеми методами управления
```tsx
function AdvancedToggle() {
  return (
    <Toggle initial={false}>
      {({ on, toggle, setOn, setOff, setState }) => (
        <div>
          <div>Статус: {on ? 'ВКЛ' : 'ВЫКЛ'}</div>
          <button onClick={toggle}>Переключить</button>
          <button onClick={setOn}>Включить</button>
          <button onClick={setOff}>Выключить</button>
          <button onClick={() => setState(true)}>Установить True</button>
          <button onClick={() => setState(false)}>Установить False</button>
        </div>
      )}
    </Toggle>
  );
}
```

### Чекбокс переключатель
```tsx
function CheckboxToggle() {
  return (
    <Toggle initial={false}>
      {({ on, toggle }) => (
        <label>
          <input
            type="checkbox"
            checked={on}
            onChange={toggle}
          />
          Включить уведомления
        </label>
      )}
    </Toggle>
  );
}
```





## Соображения производительности

- **Синхронизация состояния**: Избегайте создания нескольких переключателей для одного и того же логического состояния
- **Throttling персистентности**: Рассмотрите debouncing операций персистентности для часто переключаемых состояний
- **Оптимизация перерендера**: Используйте `React.memo` для дорогих дочерних компонентов
- **Мемоизация обработчиков событий**: Мемоизируйте обработчики событий при передаче в дорогие компоненты

```tsx
// Производительно оптимизированное использование переключателя
const OptimizedToggle = React.memo(({ children, ...props }) => (
  <Toggle {...props}>
    {(state, actions) => {
      const memoizedActions = useMemo(() => actions, [actions.toggle]);
      return children(state, memoizedActions);
    }}
  </Toggle>
));
```

## Лучшие практики

1. **Доступность**: Всегда предоставляйте правильные ARIA метки и поддержку клавиатуры
2. **Визуальная обратная связь**: Предоставляйте четкую визуальную индикацию состояния переключателя
3. **Персистентность**: Используйте персистентность для пользовательских предпочтений и настроек
4. **Валидация**: Реализуйте валидацию для критических изменений состояния
5. **Контролируемый режим**: Используйте контролируемый режим при интеграции с формами или внешним состоянием
6. **Обработка ошибок**: Изящно обрабатывайте ошибки валидации с обратной связью пользователю

## Руководство по миграции

### От useState Hook

**До:**
```tsx
function Component() {
  const [isOn, setIsOn] = useState(false);

  const toggle = () => setIsOn(prev => !prev);

  return (
    <button onClick={toggle}>
      {isOn ? 'ВКЛ' : 'ВЫКЛ'}
    </button>
  );
}
```

**После:**
```tsx
function Component() {
  return (
    <Toggle initial={false}>
      {(state, { toggle }) => (
        <button onClick={toggle}>
          {state.on ? 'ВКЛ' : 'ВЫКЛ'}
        </button>
      )}
    </Toggle>
  );
}
```

### От состояния класс-компонента

**До:**
```tsx
class Component extends React.Component {
  state = { isToggled: false };

  toggle = () => {
    this.setState(prev => ({ isToggled: !prev.isToggled }));
  };

  render() {
    return (
      <button onClick={this.toggle}>
        {this.state.isToggled ? 'ВКЛ' : 'ВЫКЛ'}
      </button>
    );
  }
}
```

**После:**
```tsx
function Component() {
  return (
    <Toggle initial={false}>
      {(state, { toggle }) => (
        <button onClick={toggle}>
          {state.on ? 'ВКЛ' : 'ВЫКЛ'}
        </button>
      )}
    </Toggle>
  );
}
```

